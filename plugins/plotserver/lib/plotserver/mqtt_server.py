import paho.mqtt.client as mqtt
import json, os, sys

sys.path.append(os.path.expanduser('~/plotserver/lib'))
from config import *


app_template = """\
# machine generated by MqttServer

import sys, os
sys.path.append(os.path.expanduser('~/plotserver/lib'))

from {module_name} import {class_name}
from bokeh.plotting import curdoc

args = {args}
kwargs = {kwargs}

lp = {class_name}("{app_name}", *args, **kwargs)
lp.app(curdoc())

print(f"serving {app_name} at http://pi4server.home/plotserver/{app_name}")
"""



class MqttServer:
    
    def __init__(self, app_dict):
        self._app_dict = app_dict
        client = self._mqttc = mqtt.Client(client_id="", clean_session=True, protocol=mqtt.MQTTv311)
        client.on_connect = self._on_connect
        client.on_disconnect = self._on_disconnect
        client.message_callback_add(f"{TOPIC_ROOT}/start", self._on_start)
        client.message_callback_add(f"{TOPIC_ROOT}/shutdown", self._on_shutdown)
        client.connect("mosquitto", port=1883, keepalive=60)
        
    def loop_forever(self):
        self._mqttc.loop_forever()

    def _on_start(self, client, userdata, message):
        # create apps/app_name.py
        app_name, module_name, class_name, args, kwargs = json.loads(message.payload)
        print("MqttServer.on_start", app_name)
        with self._app_dict as apps:
            path = os.path.expandvars(os.path.join("$IOT_PROJECTS/plotserver/apps", f"{app_name}.py"))
            try:
                app = apps.add(app_name, path)
                # create app stub
                with open(path, "w") as file:
                    file.write(app_template.format(
                        app_name=app_name, module_name=module_name, 
                        class_name=class_name, args=args, kwargs=kwargs))
                # start bokeh server
                app.start()
            except ValueError as e:
                print(f"Cannot create app: {e}")
        
    def _on_shutdown(self, client, userdata, message):
        app_name = json.loads(message.payload)
        with self._app_dict as apps:
            apps.remove(app_name)

    def _on_connect(self, client, userdata, flags, rc):
        client.subscribe(f"{TOPIC_ROOT}/start", qos=QOS)
        client.subscribe(f"{TOPIC_ROOT}/shutdown", qos=QOS)
        
    def _on_disconnect(self, client, userdata, rc):
        if rc != 0: print("Network error")
